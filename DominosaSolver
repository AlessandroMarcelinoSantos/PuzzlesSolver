//9985070
DominosaSolver = (function () {
    const height = Game.task.length, width = Game.task[0].length, length = width * height;
    let Tiles = {
        t: new Map(),
        push: function (c1) {
            'rd'.split('').forEach((c, i) => {
                const c2 = c1[c];
                if (c2) {
                    const fl = c1.v === c2.v ? c1.I < c2.I : c1.v < c2.v,
                        I = fl ? c1 : c2, // mInor value cell
                        J = fl ? c2 : c1, // maJor value cell
                        d = fl ? c : 'lu'[i], // direction from maJor to mInor 
                        o = fl ? 'lu'[i] : c, // direction from mInor to maJor (d Opposite)
                        tile = { id: I.v + J.v, I: I, J: J, d: d, o: o };
                    Tiles.t.get(tile.id).push(tile);
                    I.tiles.set(d, tile);
                    J.tiles.set(o, tile);
                }
            })
        },
        check: function (tiles) {
            if (tiles.length === 1)
                Tiles.pin(tiles[0]);
            else if (tiles.length > 1) {
                if ([...tiles.values()].every(t => t.I === tiles[0].I || t.J === tiles[0].I)) // if all mInor cells are the same
                    Tiles.remove([...tiles[0].I.tiles.values()].filter(t => t.id !== tiles[0].id)); // remove all other tiles from Cells
                else if ([...tiles.values()].every(t => t.I === tiles[0].J || t.J === tiles[0].J)) // all maJor cells are the same
                    Tiles.remove([...tiles[0].J.tiles.values()].filter(t => t.id !== tiles[0].id)); // remove all other tiles from Cells
            }
        },
        remove: function (tiles) {
            tiles.forEach(tile => {
                Cells.remove(tile);
                Tiles.print(tile, 1);
            })
        },
        print: function (tile, borders) {
            const fl = tile.I.i < tile.J.i,
                startPoint = fl ? tile.I.gameReference : tile.J.gameReference,
                endPoint = fl ? tile.J.gameReference : tile.I.gameReference;
            if (borders) {
                Math.abs(tile.I.i - tile.J.i) === 1 ? startPoint.status.borders.right = 1 : startPoint.status.borders.bottom = 1;
                startPoint.status.type = 'border';
            }
            else {
                Game.drawCellStatus(endPoint, endPoint.status);
                Game.setCellState(endPoint, endPoint.status);
            }
            Game.drawCellStatus(startPoint, startPoint.status);
            Game.setCellState(startPoint, startPoint.status);
            Game.currentState.lastMove = {
                cellStatus: startPoint.status,
                startPoint: startPoint,
                endPoint: endPoint,
                cells: [startPoint],
                direction: Math.abs(tile.I.i - tile.J.i) === 1 ? 'right' : 'down'
            };
            void Game.storeCurrentState();
        },
        pin: function (tile) {
            const status = (Math.abs(tile.I.i - tile.J.i) > 1) * 1 + (tile.I.i > tile.J.i) * 2 + 1;
            tile.I.gameReference.status.tile = status;
            tile.J.gameReference.status.tile = (status + 1) % 4 + 1;
            if (tile.I.i < tile.J.i)
                tile.I.gameReference.status.type = 'tile';
            else
                tile.J.gameReference.status.type = 'tile';
            Tiles.print(tile, 0);
            tile.I.tiles.forEach(t => Cells.remove(t));
            tile.J.tiles.forEach(t => Cells.remove(t));
            tile.I.tiles.clear();
            tile.J.tiles.clear();
            Tiles.remove(Tiles.t.get(tile.id));
        }
    };
    Array(height ** 2).fill().forEach((e, i) => {
        const f = (i / height) >> 0, l = i % height;
        if (f <= l)
            Tiles.t.set(('0' + f).slice(-2) + ('0' + l).slice(-2), []);
    });
    let Cells = {
        c: Array(length).fill().map(() => ({})),
        push: function (task, row, col) {
            const i = row * width + col,
                cell = Cells.c[i];
            Object.assign(cell, {
                i: i,
                v: ('0' + task).slice(-2),
                gameReference: {
                    row: row,
                    col: col,
                    status: { tile: 0, borders: { right: 0, bottom: 0 } } //, type: 'tile'
                },
                r: col < width - 1 && Cells.c[i + 1],
                u: row > 0 && Cells.c[i - width],
                l: col > 0 && Cells.c[i - 1],
                d: row < height - 1 && Cells.c[i + width],
                c: null, //Cluster
                tiles: new Map()
            });
        },
        remove: function (tile) {
            if (Tiles.t.has(tile.id))
                Tiles.t.set(tile.id, Tiles.t.get(tile.id).filter(t => t !== tile));
            tile.I.tiles.delete(tile.d);
            tile.J.tiles.delete(tile.o);
        },
        check: function (cell) {
            Game.getDomElement(cell.gameReference).css({ "background-color": '' });
            if (cell.tiles.size === 1)
                Tiles.pin([...cell.tiles.values()][0]);
            else if (cell.tiles.size === 2) {
                const tiles = [...cell.tiles.values()],
                    oCells = tiles.map(t => t.I != cell && t.I || t.J != cell && t.J);
                oCells[0].tiles.forEach(t => t.id === tiles[1].id && t !== tiles[0] && Tiles.remove([t])); // Remove tiles that force duplicate selection
                oCells[1].tiles.forEach(t => t.id === tiles[0].id && t !== tiles[1] && Tiles.remove([t]));
            }
            else {
                const tilesIds = [...cell.tiles.values()].map(t => t.id),
                    uniqueTile = [...cell.tiles.values()].find((t, i, s) => s.filter( f => f.id === t.id ).length === 1);
                if ([...new Set(tilesIds)].length === 2 && uniqueTile && uniqueTile.I.v === uniqueTile.J.v) {
                    const oCell = uniqueTile.I === cell ? uniqueTile.J : uniqueTile.I,
                        repeatedTilesId = [...new Set(tilesIds)].filter(t => t !== uniqueTile.id)[0];
                    oCell.tiles.forEach(t => t.id === repeatedTilesId && Tiles.remove([t])); // Remove tiles that force duplicate selection
                }
            }
            if (cell.tiles.size > 1) {
                const tiles = [...cell.tiles.values()],
                    distinctIds = [... new Set(tiles.map(t => t.id))].sort();
                if (distinctIds.length === 1) // if all tiles of a cell are equivalents
                    Tiles.remove(Tiles.t.get(tiles[0].id).filter(t => !tiles.includes(t))); // remove all other tiles from Tiles
                else if (distinctIds.length === 2) {
                    const sameValueCells = Cells.c.filter(c => c.v === cell.v && !cell.gameReference.status.tile && c !== cell); // If another cell have equivalent tiles set remove all other tiles from Tiles
                    let tilesToFilter = [tiles];
                    sameValueCells.forEach(svc => {
                        const otherCellsTiles = [...svc.tiles.values()];
                        if ([...new Set(otherCellsTiles.map(t => t.id))].sort().join() === distinctIds.join())
                            tilesToFilter = tilesToFilter.push(otherCellsTiles)
                    })
                    if (tilesToFilter.length === distinctIds.length)
                        distinctIds.forEach(dt => Tiles.remove(Tiles.t.get(dt).filter(t => !tilesToFilter.flat().includes(t))))
                }
            }
        }
    }
    Game.task.forEach((row, r) =>
        row.forEach((task, c) => Cells.push(task, r, c))
    );
    Cells.c.forEach(cell => Tiles.push(cell));
    let Cluster = {
        check: function (cell) {
            if (!cell.gameReference.status.tile) {
                const ds = 'ruld'.split('').filter(d => cell.tiles.has(d)).join('');
                if (ds.length === 2 && 'rdld'.includes(ds)) // 'rd' or 'ld' start to check a cluster
                    Cluster.start(cell, ds);
            }
        },
        start: function (cell, ds) {
            let exits = [], // exits from cluster
                path = new Map(),
                f = ds[0] === 'r' ? 'r' : 'd', // following direction
                l = ds[0] === 'r' ? 'u' : 'r', // last (following) direction
                o,
                x = 0, // x start relative coordinate
                y = 0, // y start relative coordinate
                next = cell;
            function opp(d) { return 'ldru'['ruld'.indexOf(d)] }

            let color = '#' + Array(3).fill().map(clt => ((30 + Math.random() * 200) >> 0).toString(16)).join('')
            do {
                Game.getDomElement(next.gameReference).css({ "background-color": color });
                if (exits.length === 1) debugger;
                if (next.tiles.has(l)) {                                                    //  If can move on the last direction
                    if (!next[l].tiles.has(f) || !next[f].tiles.has(l)) {                   //      If can't move to diagonal "last direction" + "following direction"
                        exits.push({ cell: next, ds: l });                                  //          Mark exit on last direction
                        if (!next.tiles.has(f))                                             //          If can't move on following direction
                            o = opp(l), l = f, f = o;                                       //              Turn to last direction's opposite
                        else if (!next[f].tiles.has(opp(l)) || !next[opp(l)].tiles.has(f))  //          Else if can't move on diagonal "last direction's opposite" + "following direction"
                            exits.push({});                                                 //              Mark a 2nd exit on same cell (break)
                    }
                    else if (!next.tiles.has(f))                                            //      Else if can't move on following direction
                        exits.push({ cell: next, ds: l }), o = opp(l), l = f, f = o;        //          Mark exit on last direction and turn to last direction's opposite
                    else if (!next[f].tiles.has(opp(l)) || !next[opp(l)].tiles.has(f))      //      Else if can't move on diagonal "last direction's opposite" + "following direction"
                        exits.push({ cell: next, ds: f + l }), o = opp(l), l = f, f = o;    //          Mark exit on "following + last" directions and turn to last direction's opposite
                    else                                                                    //      Else
                        o = opp(f), f = l, l = o;                                           //           turn to last direction
                }
                else if (next.tiles.has(f)) {                                               //  Else if can move on following direction
                    if (!next[f].tiles.has(opp(l)) || !next[opp(l)].tiles.has(f))           //      If can't move on diagonal "last direction's opposite" + "following direction"
                        exits.push({ cell: next, ds: f }), o = opp(l), l = f, f = o;        //          Mark exit on following direction and turn to last direction's opposite
                }
                else                                                                        //  Else
                    o = opp(l), l = f, f = o;                                               //      Turn to last direction's opposite

                next = next[f];
                [() => x++, () => y--, () => x--, () => y++]['ruld'.indexOf(f)]();
                !path.has(y) && path.set(y, []);
                path.get(y).push({ d: f, x: x });
            }
            while (exits.length < 2 && next !== cell);
            if (next === cell && exits.length === 1) {
                path.forEach(p => p = p.sort((a, b) => a.x - b.x));
                let holes = [...path].map((p, i, s) => {
                    let ret = 0;
                    if (i < s.length - 1) {
                        let a = p, b = s[i + 1];
                        ret = a.d = "r" ? (b.d = "d" ? 0 : b.x - a.x - 1) : (a.d = "d" ? (b.d = "r" ? 0 : b.x - a.x - 1) : 0);
                    }
                    return ret;
                }).flat().reduce((a, b) => a + b);
                let diffs = [...path.values()].map(p => Math.max(...p.map(px => px.x)) - Math.min(...p.map(px => px.x)) + 1).reduce((a, b) => a + b);
                //if (exits.length === 1) debugger;
                if ((diffs - holes) % 2 === 0)
                    exits[0].ds.split('').forEach(d => exits[0].cell.tiles.has(d) && Tiles.remove([exits[0].cell.tiles.get(d)]));
                else
                    'ruld'.split('').forEach(d => !exits[0].ds.includes(d) && exits[0].cell.tiles.has(d) && Tiles.remove([exits[0].cell.tiles.get(d)]));
            }
        }
    };
    let Block = {
        check: function(tile, block) {
            const oTiles = Array.concat( [...tile.I.tiles.values()].find(t => t !== tile);
            if(tile.I.tiles.size === 2){
                
            }
        }
    };
    let check = function () {
        Tiles.t.forEach(t => Tiles.check(t));
        Cells.c.forEach(c => Cells.check(c));
        Cells.c.forEach(c => Cluster.check(c));
    }
    for (let i = 0; i < width; i++) check();
    return { Tiles: Tiles, Cells: Cells, check: check }
})()